require("main.language_fixes")



suits = {"hearts", "diamonds", "clubs", "spades"}
values = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king", "ace"}
deck ={}




function PlayCards()
  deck=generateDeck()-- test the cards in the deck
  deck=ShuffleDeck()-- shuffle the deck 
  -- for i=1, #deck do
  --   print(deck[i].value.." of "..deck[i].suit)
  -- end
end  

function ShuffleDeck()
  for i=1, #deck do
    local j = math.random(i, #deck)
    deck[i], deck[j] = deck[j], deck[i]
  end
  return deck
end

function generateDeck()
  newdeck = {}
  for i, suit in ipairs(suits) do
    for j, value in ipairs(values) do
      table.insert(newdeck, {suit = suit, value = value})
    end
  end
  return newdeck  -- return the deck
end


function init(self)

  PlayCards()
  target_pos = go.get_world_position("/1")
  print("target_pos")
  print(target_pos.x)
  print(target_pos.y)
  create_and_animate_card(self, "ace_of_spades", target_pos.x, target_pos.y)

end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("Touch!")
	end
end

function create_and_animate_card(self, card_id, pos_x, pos_y)
  print("create_and_animate_card")
  print(card_id)
  new_card_ids = collectionfactory.create("#cardCollectionfactory")
  new_card = new_card_ids[hash("/Card")]
  print("Inside init")
 
  msg.post(new_card, "play_animation", {id = hash(card_id)})
  delay = 1
  duration = 2 
  go.animate(new_card, "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x, go.EASING_LINEAR, duration, delay)
  go.animate(new_card, "position.y", go.PLAYBACK_ONCE_FORWARD, pos_y, go.EASING_LINEAR, duration, delay)

end


-- function set_sprite_on_card(self, new_card)

--   -- assign animation to the sprite component inside the Card collection that was loaded
--   msg.post(new_card, "play_animation", {id = hash("ace_of_spades")})
-- end

