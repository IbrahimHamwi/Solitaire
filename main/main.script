require("main.language_fixes")

suits = {"_of_hearts", "_of_diamonds", "_of_clubs", "_of_spades"}
values = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king", "ace"}
deck ={}


function PlayCards()
  deck=generateDeck()-- test the cards in the deck
  deck=Shuffle(deck)
  -- for i=1, #deck do
  --   print(deck[i].value.." of "..deck[i].suit)
  -- end
  -- pprint(deck)
end  

function Shuffle(deck)
    local s = {}
    for i = 1, #deck do s[i] = deck[i] end
    for i = #deck, 2, -1 do
        local j = math.random(i)
        s[i], s[j] = s[j], s[i]
    end
    return s
end

function generateDeck()
  newdeck = {}
  for i, suit in ipairs(suits) do
    for j, value in ipairs(values) do
      table.insert(newdeck, {suit = suit, value = value})
    end
  end
  return newdeck  -- return the deck
end

function init(self)
  math.randomseed(os.time())
  PlayCards()
  -- print("target_pos")
  -- print(target_pos.x)
  -- print(target_pos.y)
  print("the first card is "..deck[1].value..deck[1].suit)
  -- target_pos = go.get_world_position("/6")
  -- create_and_animate_card(self, deck[1].value..deck[1].suit, target_pos.x, target_pos.y)
  iteration=0

  for i=1,7 do
    for j=i,7 do
      -- iteration = iteration + 1
      -- print("iteration "..iteration)
      target_pos = go.get_world_position("/"..j)
      offsety=(i-1)*60
      isopened = i==j
      create_and_animate_card(self, deck[1].value..deck[1].suit, target_pos.x, target_pos.y-offsety,i/10,isopened)
      table.remove(deck,1)
      -- msg.post("/collection"..i.."/back#back_sprite", "enable")
      -- msg.post("/collection"..(iteration-1).."/back#back_sprite", "disable")
      -- msg.post("/collection"..(iteration-1).."/face#face_sprite", "enable")
    end
  end
end


function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("Touch!")
	end
end

function create_and_animate_card(self, card_id, pos_x, pos_y,delay,is_opened)
  print("create_and_animate_card")

  new_card_ids = collectionfactory.create("#cardFactory" )
  -- pprint(new_card_ids)
  -- returns the identities of the spawned game objects as a table.
  -- The table keys map the hash of the collection-local id of each object to the runtime id of each object
  new_card = new_card_ids[hash("/Card")]
  new_card_face = new_card_ids[hash("/face")]-- get the face of the card
  new_card_back = new_card_ids[hash("/back")]-- get the back of the card
  go.set_scale(0.4, new_card_face)
  go.set_scale(0.42, new_card_back)  -- scale the card
  -------------------------------------  ------------------------------

  local script_url = msg.url(nil, new_card, "card")

  -- go.set(script_url, "is_opened", is_opened)
  msg.post(script_url, "set_card_id", {card_id = card_id})
  msg.post(script_url, "set_opened", {is_opened = is_opened})

  duration = 1.0 
  go.animate(new_card, "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x, go.EASING_LINEAR, duration, delay)
  go.animate(new_card, "position.y", go.PLAYBACK_ONCE_FORWARD, pos_y, go.EASING_LINEAR, duration, delay)
end

